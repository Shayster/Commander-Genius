<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Commander Genius: COpenGL.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>COpenGL.cpp</h1>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * COpenGL.cpp</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> *  Created on: 04.06.2009</span>
<a name="l00005"></a>00005 <span class="comment"> *      Author: gerstrong</span>
<a name="l00006"></a>00006 <span class="comment"> */</span>
<a name="l00007"></a>00007 <span class="preprocessor">#ifdef USE_OPENGL</span>
<a name="l00008"></a>00008 <span class="preprocessor"></span>
<a name="l00009"></a>00009 <span class="preprocessor">#include &quot;COpenGL.h&quot;</span>
<a name="l00010"></a>00010 <span class="preprocessor">#include &quot;CVideoDriver.h&quot;</span>
<a name="l00011"></a>00011 <span class="preprocessor">#include &quot;../CLogFile.h&quot;</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include &quot;CInput.h&quot;</span> <span class="comment">// for CInput::renderOverlay</span>
<a name="l00013"></a>00013 <span class="comment"></span>
<a name="l00014"></a>00014 <span class="comment">/**</span>
<a name="l00015"></a>00015 <span class="comment"> * This function calculates an equivalent value near by the power of two. That is needed so we support POT Textures</span>
<a name="l00016"></a>00016 <span class="comment"> */</span>
<a name="l00017"></a>00017 Uint16 getPowerOfTwo(Uint16 value)
<a name="l00018"></a>00018 {
<a name="l00019"></a>00019  Uint16 output = 1;
<a name="l00020"></a>00020  <span class="keywordflow">while</span> (output&lt;value)
<a name="l00021"></a>00021   output &lt;&lt;= 1;
<a name="l00022"></a>00022  <span class="keywordflow">return</span> output;
<a name="l00023"></a>00023 }
<a name="l00024"></a>00024 
<a name="l00025"></a>00025 <span class="comment">// gamerect is the base resolution for the game which is scaled with the filter</span>
<a name="l00026"></a>00026 <span class="comment">// depending on what resolution has been chosen, it is mostly 320x200 or 320x240</span>
<a name="l00027"></a>00027 COpenGL::COpenGL(Uint16 Width, Uint16 Height, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> Depth,
<a name="l00028"></a>00028     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> scalex,SDL_Rect &amp;gamestdrect) :
<a name="l00029"></a>00029 mp_blitsurface(NULL),
<a name="l00030"></a>00030 mp_fgsurface(NULL),
<a name="l00031"></a>00031 mp_fxsurface(NULL),
<a name="l00032"></a>00032 m_opengl_buffer(NULL),
<a name="l00033"></a>00033 m_Depth(Depth),
<a name="l00034"></a>00034 m_ScaleX(scalex),
<a name="l00035"></a>00035 m_texparam(GL_TEXTURE_2D),
<a name="l00036"></a>00036 m_aspectratio(Width/Height),
<a name="l00037"></a>00037 m_GamePOTBaseDim(getPowerOfTwo(gamestdrect.w),
<a name="l00038"></a>00038     getPowerOfTwo(gamestdrect.h)),
<a name="l00039"></a>00039 m_GamePOTVideoDim(getPowerOfTwo(Width),
<a name="l00040"></a>00040     getPowerOfTwo(Height))
<a name="l00041"></a>00041 {
<a name="l00042"></a>00042 }
<a name="l00043"></a>00043 
<a name="l00044"></a>00044 <span class="keyword">static</span> <span class="keywordtype">void</span> createTexture(GLuint&amp; tex, <span class="keywordtype">int</span> oglfilter, GLsizei potwidth, GLsizei potheight, <span class="keywordtype">bool</span> withAlpha = <span class="keyword">false</span>) {
<a name="l00045"></a>00045  glGenTextures(1, &amp;tex);
<a name="l00046"></a>00046  glBindTexture(GL_TEXTURE_2D, tex);
<a name="l00047"></a>00047  glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
<a name="l00048"></a>00048 
<a name="l00049"></a>00049  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
<a name="l00050"></a>00050  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
<a name="l00051"></a>00051 
<a name="l00052"></a>00052  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, oglfilter);
<a name="l00053"></a>00053  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, oglfilter);
<a name="l00054"></a>00054 
<a name="l00055"></a>00055  glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
<a name="l00056"></a>00056 
<a name="l00057"></a>00057  <span class="keywordflow">if</span>(withAlpha)
<a name="l00058"></a>00058   glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, potwidth, potheight, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);
<a name="l00059"></a>00059  <span class="keywordflow">else</span>
<a name="l00060"></a>00060   glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, potwidth, potheight, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL);
<a name="l00061"></a>00061 }
<a name="l00062"></a>00062 
<a name="l00063"></a>00063 <span class="keywordtype">bool</span> COpenGL::initGL(GLint oglfilter)
<a name="l00064"></a>00064 {
<a name="l00065"></a>00065  <span class="keywordflow">if</span>(m_Depth != 32)
<a name="l00066"></a>00066  {
<a name="l00067"></a>00067   <span class="comment">// TODO: I know, this is an issue, but I need to investigate, how pixels in SDL are stored when using</span>
<a name="l00068"></a>00068   <span class="comment">// 16 bit depth copy it correctly to the OGL Texture</span>
<a name="l00069"></a>00069   g_pLogFile-&gt;textOut(<span class="stringliteral">&quot;Sorry, but OpenGL with 16 bpp is not supported! Please switch to 32 bpp mode!&quot;</span>);
<a name="l00070"></a>00070   <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00071"></a>00071  }
<a name="l00072"></a>00072 
<a name="l00073"></a>00073  <span class="comment">// Calculate the proper viewport for any resolution</span>
<a name="l00074"></a>00074  <span class="keywordtype">float</span> base_width = g_pVideoDriver-&gt;getGameResolution().w;
<a name="l00075"></a>00075  <span class="keywordtype">float</span> base_height = g_pVideoDriver-&gt;getGameResolution().h;
<a name="l00076"></a>00076 
<a name="l00077"></a>00077  <span class="keywordtype">float</span> scale_width = (float)(g_pVideoDriver-&gt;getWidth())/base_width;
<a name="l00078"></a>00078  <span class="keywordtype">float</span> scale_height = (float)(g_pVideoDriver-&gt;getHeight())/base_height;
<a name="l00079"></a>00079 
<a name="l00080"></a>00080  <span class="keywordtype">float</span> width = ((float)m_GamePOTBaseDim.w)*scale_width;
<a name="l00081"></a>00081  <span class="keywordtype">float</span> height = ((float)m_GamePOTBaseDim.h)*scale_height;
<a name="l00082"></a>00082  <span class="keywordtype">float</span> ypos = (base_height-m_GamePOTBaseDim.h)*scale_height;
<a name="l00083"></a>00083  <span class="keywordtype">float</span> xpos = 0.0f; <span class="comment">// Not needed because the x-axis of ogl and sdl_surfaces are the same.</span>
<a name="l00084"></a>00084 
<a name="l00085"></a>00085  <span class="comment">// strange constants here; 225 seems good for pc. 200 is better for iphone</span>
<a name="l00086"></a>00086  <span class="comment">// the size is the same as the texture buffers</span>
<a name="l00087"></a>00087  glViewport(xpos, ypos, width, height);
<a name="l00088"></a>00088 
<a name="l00089"></a>00089  <span class="comment">// Set clear colour</span>
<a name="l00090"></a>00090  glClearColor(0,0,0,0);
<a name="l00091"></a>00091  
<a name="l00092"></a>00092  <span class="comment">// Set projection</span>
<a name="l00093"></a>00093  glMatrixMode( GL_PROJECTION );
<a name="l00094"></a>00094  glLoadIdentity();
<a name="l00095"></a>00095 
<a name="l00096"></a>00096 <span class="preprocessor"> #if defined(TARGET_OS_IPHONE) || defined(TARGET_IPHONE_SIMULATOR) // TODO: dont check for iphone but for opengles</span>
<a name="l00097"></a>00097 <span class="preprocessor"></span><span class="preprocessor">#define glOrtho glOrthof</span>
<a name="l00098"></a>00098 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00099"></a>00099 <span class="preprocessor"></span> glOrtho( 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f );
<a name="l00100"></a>00100 
<a name="l00101"></a>00101  <span class="comment">// Now Initialize modelview matrix</span>
<a name="l00102"></a>00102  glMatrixMode( GL_MODELVIEW );
<a name="l00103"></a>00103  glLoadIdentity();
<a name="l00104"></a>00104     <span class="comment">/*Using the standard OpenGL API for specifying a 2D texture</span>
<a name="l00105"></a>00105 <span class="comment">    image: glTexImage2D, glSubTexImage2D, glCopyTexImage2D,</span>
<a name="l00106"></a>00106 <span class="comment">    and glCopySubTexImage2D.  The target for these commands is</span>
<a name="l00107"></a>00107 <span class="comment">    GL_TEXTURE_RECTANGLE_ARB though.</span>
<a name="l00108"></a>00108 <span class="comment"></span>
<a name="l00109"></a>00109 <span class="comment">    This is similar to how the texture cube map functionality uses the 2D</span>
<a name="l00110"></a>00110 <span class="comment">    texture image specification API though with its own texture target.</span>
<a name="l00111"></a>00111 <span class="comment"></span>
<a name="l00112"></a>00112 <span class="comment">    The texture target GL_TEXTURE_RECTANGLE_ARB should also</span>
<a name="l00113"></a>00113 <span class="comment">    be used for glGetTexImage, glGetTexLevelParameteriv, and</span>
<a name="l00114"></a>00114 <span class="comment">    glGetTexLevelParameterfv.*/</span>
<a name="l00115"></a>00115 
<a name="l00116"></a>00116  <span class="comment">// Enable Texture loading for the blit screen</span>
<a name="l00117"></a>00117  <span class="comment">/*glEnable (m_texparam);</span>
<a name="l00118"></a>00118 <span class="comment"> glBindTexture(m_texparam, 1);</span>
<a name="l00119"></a>00119 <span class="comment"> glPixelStorei(GL_UNPACK_ALIGNMENT, 1);</span>
<a name="l00120"></a>00120 <span class="comment"></span>
<a name="l00121"></a>00121 <span class="comment"> glTexParameteri(m_texparam, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span>
<a name="l00122"></a>00122 <span class="comment"> glTexParameteri (m_texparam, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span>
<a name="l00123"></a>00123 <span class="comment"></span>
<a name="l00124"></a>00124 <span class="comment"></span>
<a name="l00125"></a>00125 <span class="comment"> glTexParameteri (m_texparam, GL_TEXTURE_MAG_FILTER, oglfilter);</span>
<a name="l00126"></a>00126 <span class="comment"> glTexParameteri (m_texparam, GL_TEXTURE_MIN_FILTER, oglfilter);</span>
<a name="l00127"></a>00127 <span class="comment"></span>
<a name="l00128"></a>00128 <span class="comment"> glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);*/</span>
<a name="l00129"></a>00129 
<a name="l00130"></a>00130  glEnable(m_texparam);
<a name="l00131"></a>00131 
<a name="l00132"></a>00132  createTexture(m_texture, oglfilter, m_GamePOTVideoDim.w, m_GamePOTVideoDim.h);
<a name="l00133"></a>00133  
<a name="l00134"></a>00134  <span class="keywordflow">if</span>(m_ScaleX &gt; 1)
<a name="l00135"></a>00135  {
<a name="l00136"></a>00136   m_opengl_buffer = <span class="keyword">new</span> <span class="keywordtype">char</span>[m_GamePOTVideoDim.w*m_GamePOTVideoDim.h*m_ScaleX*m_Depth];
<a name="l00137"></a>00137  }
<a name="l00138"></a>00138  <span class="keywordflow">else</span>
<a name="l00139"></a>00139  { <span class="comment">// In that case we can do a texture based rendering</span>
<a name="l00140"></a>00140   createTexture(m_texFX, oglfilter, m_GamePOTVideoDim.w, m_GamePOTVideoDim.h, <span class="keyword">true</span>);
<a name="l00141"></a>00141   createTexture(m_texFG, oglfilter, m_GamePOTVideoDim.w, m_GamePOTVideoDim.h, <span class="keyword">true</span>);
<a name="l00142"></a>00142   m_opengl_buffer = NULL;
<a name="l00143"></a>00143  }
<a name="l00144"></a>00144  
<a name="l00145"></a>00145  <span class="comment">// If there were any errors</span>
<a name="l00146"></a>00146  <span class="keywordtype">int</span> error;
<a name="l00147"></a>00147  error = glGetError();
<a name="l00148"></a>00148  <span class="keywordflow">if</span>( error != GL_NO_ERROR)
<a name="l00149"></a>00149  {
<a name="l00150"></a>00150   g_pLogFile-&gt;ftextOut(<span class="stringliteral">&quot;OpenGL Init(): %d&lt;br&gt;&quot;</span>,error);
<a name="l00151"></a>00151   <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00152"></a>00152  }
<a name="l00153"></a>00153  <span class="keywordflow">else</span>
<a name="l00154"></a>00154  {
<a name="l00155"></a>00155   g_pLogFile-&gt;ftextOut(<span class="stringliteral">&quot;OpenGL Init(): Interface succesfully opened!&lt;br&gt;&quot;</span>);
<a name="l00156"></a>00156  }
<a name="l00157"></a>00157  
<a name="l00158"></a>00158  <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00159"></a>00159 }
<a name="l00160"></a>00160 
<a name="l00161"></a>00161 <span class="keywordtype">void</span> COpenGL::setBlitSurface(SDL_Surface *blitsurface)
<a name="l00162"></a>00162 { mp_blitsurface = blitsurface; }
<a name="l00163"></a>00163 
<a name="l00164"></a>00164 <span class="keywordtype">void</span> COpenGL::setFGSurface(SDL_Surface *fgsurface)
<a name="l00165"></a>00165 { mp_fgsurface = fgsurface; }
<a name="l00166"></a>00166 <span class="keywordtype">void</span> COpenGL::setFXSurface(SDL_Surface *fxsurface)
<a name="l00167"></a>00167 { mp_fxsurface = fxsurface; }
<a name="l00168"></a>00168 
<a name="l00169"></a>00169 
<a name="l00170"></a>00170 <span class="comment">/*static void loadSurface(GLuint texture, SDL_Surface* surface) {</span>
<a name="l00171"></a>00171 <span class="comment"> glBindTexture(GL_TEXTURE_2D, texture);</span>
<a name="l00172"></a>00172 <span class="comment"> LockSurface(surface);</span>
<a name="l00173"></a>00173 <span class="comment"> if(surface-&gt;format-&gt;BitsPerPixel == 24)</span>
<a name="l00174"></a>00174 <span class="comment">  glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 512, 256, 0, GL_RGB, GL_UNSIGNED_BYTE, surface-&gt;pixels);</span>
<a name="l00175"></a>00175 <span class="comment"> else {</span>
<a name="l00176"></a>00176 <span class="comment">  // we assume RGBA</span>
<a name="l00177"></a>00177 <span class="comment">  glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 512, 256, 0, GL_RGBA, GL_UNSIGNED_BYTE, surface-&gt;pixels);</span>
<a name="l00178"></a>00178 <span class="comment"> }</span>
<a name="l00179"></a>00179 <span class="comment"> UnlockSurface(surface);</span>
<a name="l00180"></a>00180 <span class="comment">}*/</span>
<a name="l00181"></a>00181 
<a name="l00182"></a>00182 <span class="keywordtype">void</span> COpenGL::reloadFX(SDL_Surface* surf) {
<a name="l00183"></a>00183  loadSurface(m_texFX, surf);
<a name="l00184"></a>00184 }
<a name="l00185"></a>00185 
<a name="l00186"></a>00186 <span class="keywordtype">void</span> COpenGL::reloadFG(SDL_Surface* surf) {
<a name="l00187"></a>00187  loadSurface(m_texFG, surf);
<a name="l00188"></a>00188 }
<a name="l00189"></a>00189 
<a name="l00190"></a>00190 <span class="keyword">static</span> <span class="keywordtype">void</span> renderTexture(GLuint texture, <span class="keywordtype">bool</span> withAlpha = <span class="keyword">false</span>) {
<a name="l00191"></a>00191  
<a name="l00192"></a>00192  <span class="comment">// Set up an array of values to use as the sprite vertices.</span>
<a name="l00193"></a>00193  GLfloat vertices[] =
<a name="l00194"></a>00194  {
<a name="l00195"></a>00195   0, 0,
<a name="l00196"></a>00196   1, 0,
<a name="l00197"></a>00197   1, 1,
<a name="l00198"></a>00198   0, 1,
<a name="l00199"></a>00199  };
<a name="l00200"></a>00200 
<a name="l00201"></a>00201  <span class="comment">// Set up an array of values for the texture coordinates.</span>
<a name="l00202"></a>00202  GLfloat texcoords[] =
<a name="l00203"></a>00203  {
<a name="l00204"></a>00204   0, 0,
<a name="l00205"></a>00205   1, 0,
<a name="l00206"></a>00206   1, 1,
<a name="l00207"></a>00207   0, 1,
<a name="l00208"></a>00208  };
<a name="l00209"></a>00209 
<a name="l00210"></a>00210  <span class="comment">//Render the vertices by pointing to the arrays.</span>
<a name="l00211"></a>00211     glEnableClientState(GL_VERTEX_ARRAY);
<a name="l00212"></a>00212     glEnableClientState(GL_TEXTURE_COORD_ARRAY);
<a name="l00213"></a>00213 
<a name="l00214"></a>00214  glVertexPointer(2, GL_FLOAT, 0, vertices);
<a name="l00215"></a>00215  glTexCoordPointer(2, GL_FLOAT, 0, texcoords);
<a name="l00216"></a>00216 
<a name="l00217"></a>00217  glEnable(GL_BLEND);
<a name="l00218"></a>00218  <span class="keywordflow">if</span>(withAlpha)
<a name="l00219"></a>00219   <span class="comment">//glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA /*GL_SRC_COLOR*/);</span>
<a name="l00220"></a>00220   glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
<a name="l00221"></a>00221  <span class="keywordflow">else</span>
<a name="l00222"></a>00222   glBlendFunc(GL_ONE, GL_ZERO <span class="comment">/*GL_SRC_COLOR*/</span>);
<a name="l00223"></a>00223 
<a name="l00224"></a>00224  glBindTexture (GL_TEXTURE_2D, texture);
<a name="l00225"></a>00225  glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
<a name="l00226"></a>00226  
<a name="l00227"></a>00227  <span class="comment">// Set the texture parameters to use a linear filter when minifying.</span>
<a name="l00228"></a>00228  <span class="comment">//glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span>
<a name="l00229"></a>00229  
<a name="l00230"></a>00230  <span class="comment">//Finally draw the arrays.</span>
<a name="l00231"></a>00231  glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
<a name="l00232"></a>00232  glDisableClientState(GL_VERTEX_ARRAY);
<a name="l00233"></a>00233     glDisableClientState(GL_TEXTURE_COORD_ARRAY);
<a name="l00234"></a>00234  glDisable(GL_BLEND);
<a name="l00235"></a>00235 }
<a name="l00236"></a>00236 
<a name="l00237"></a>00237 <span class="keywordtype">void</span> COpenGL::loadSurface(GLuint texture, SDL_Surface* surface)
<a name="l00238"></a>00238 {
<a name="l00239"></a>00239  glBindTexture (m_texparam, texture);
<a name="l00240"></a>00240  LockSurface(surface);
<a name="l00241"></a>00241  GLint internalFormat, externalFormat;
<a name="l00242"></a>00242 <span class="preprocessor">#if !defined(TARGET_OS_IPHONE) &amp;&amp; !defined(TARGET_IPHONE_SIMULATOR) // iPhone always used 32 bits; also GL_BGR is not defined</span>
<a name="l00243"></a>00243 <span class="preprocessor"></span> <span class="keywordflow">if</span>(surface-&gt;format-&gt;BitsPerPixel == 24)
<a name="l00244"></a>00244  {
<a name="l00245"></a>00245   internalFormat = GL_RGB;
<a name="l00246"></a>00246   externalFormat = GL_BGR;
<a name="l00247"></a>00247  }
<a name="l00248"></a>00248  <span class="keywordflow">else</span>
<a name="l00249"></a>00249 <span class="preprocessor">#endif</span>
<a name="l00250"></a>00250 <span class="preprocessor"></span> { <span class="comment">// we assume RGBA</span>
<a name="l00251"></a>00251   internalFormat = GL_RGBA;
<a name="l00252"></a>00252   externalFormat = GL_BGRA;
<a name="l00253"></a>00253  }
<a name="l00254"></a>00254 
<a name="l00255"></a>00255  <span class="keywordflow">if</span>(m_ScaleX &gt; 1) <span class="comment">//ScaleX</span>
<a name="l00256"></a>00256  {
<a name="l00257"></a>00257   <span class="keywordtype">unsigned</span> m_src_slice = m_GamePOTBaseDim.w*surface-&gt;format-&gt;BytesPerPixel;
<a name="l00258"></a>00258   <span class="keywordtype">unsigned</span> m_dst_slice = m_ScaleX*m_src_slice;
<a name="l00259"></a>00259 
<a name="l00260"></a>00260 
<a name="l00261"></a>00261   scale(m_ScaleX, m_opengl_buffer, m_dst_slice, surface-&gt;pixels,
<a name="l00262"></a>00262     m_src_slice, surface-&gt;format-&gt;BytesPerPixel,
<a name="l00263"></a>00263     m_GamePOTBaseDim.w, m_GamePOTBaseDim.h);
<a name="l00264"></a>00264 
<a name="l00265"></a>00265    glTexImage2D(m_texparam, 0, internalFormat, m_GamePOTBaseDim.w*m_ScaleX, m_GamePOTBaseDim.h*m_ScaleX,
<a name="l00266"></a>00266               0, externalFormat, GL_UNSIGNED_BYTE, m_opengl_buffer);
<a name="l00267"></a>00267  }
<a name="l00268"></a>00268  <span class="keywordflow">else</span>
<a name="l00269"></a>00269  {
<a name="l00270"></a>00270    glTexImage2D(m_texparam, 0, internalFormat, m_GamePOTBaseDim.w, m_GamePOTBaseDim.h,
<a name="l00271"></a>00271               0, externalFormat, GL_UNSIGNED_BYTE, surface-&gt;pixels);
<a name="l00272"></a>00272  }
<a name="l00273"></a>00273 
<a name="l00274"></a>00274  UnlockSurface(surface);
<a name="l00275"></a>00275 }
<a name="l00276"></a>00276 
<a name="l00277"></a>00277 <span class="keywordtype">void</span> COpenGL::render()
<a name="l00278"></a>00278 {
<a name="l00279"></a>00279  <span class="comment">//glClearColor(0.0f, 0.0f, 0.0f, 0.0f);</span>
<a name="l00280"></a>00280 
<a name="l00281"></a>00281  loadSurface(m_texture, mp_blitsurface);
<a name="l00282"></a>00282  renderTexture(m_texture);
<a name="l00283"></a>00283 
<a name="l00284"></a>00284  g_pInput-&gt;renderOverlay();
<a name="l00285"></a>00285 
<a name="l00286"></a>00286  <span class="keywordflow">if</span>(mp_fgsurface)
<a name="l00287"></a>00287  {
<a name="l00288"></a>00288   reloadFG(mp_fgsurface);
<a name="l00289"></a>00289   renderTexture(m_texFG, <span class="keyword">true</span>);
<a name="l00290"></a>00290  }
<a name="l00291"></a>00291 
<a name="l00292"></a>00292  <span class="keywordflow">if</span>(mp_fxsurface)
<a name="l00293"></a>00293  {
<a name="l00294"></a>00294   reloadFX(mp_fgsurface);
<a name="l00295"></a>00295   renderTexture(m_texFG, <span class="keyword">true</span>);
<a name="l00296"></a>00296  }
<a name="l00297"></a>00297  
<a name="l00298"></a>00298  SDL_GL_SwapBuffers();
<a name="l00299"></a>00299 
<a name="l00300"></a>00300 }
<a name="l00301"></a>00301 
<a name="l00302"></a>00302 COpenGL::~COpenGL() {
<a name="l00303"></a>00303  <span class="keywordflow">if</span>(m_opengl_buffer)
<a name="l00304"></a>00304   <span class="keyword">delete</span>[] m_opengl_buffer;
<a name="l00305"></a>00305  m_opengl_buffer = NULL;
<a name="l00306"></a>00306 }
<a name="l00307"></a>00307 
<a name="l00308"></a>00308 <span class="preprocessor">#endif // USE_OPENGL</span>
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
