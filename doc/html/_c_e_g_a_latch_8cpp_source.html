<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Commander Genius: CEGALatch.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>CEGALatch.cpp</h1>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * CEGALatch.cpp</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> *  Created on: 11.07.2009</span>
<a name="l00005"></a>00005 <span class="comment"> *      Author: gerstrong</span>
<a name="l00006"></a>00006 <span class="comment"> */</span>
<a name="l00007"></a>00007 
<a name="l00008"></a>00008 <span class="preprocessor">#include &quot;CEGALatch.h&quot;</span>
<a name="l00009"></a>00009 <span class="preprocessor">#include &quot;../../fileio/ResourceMgmt.h&quot;</span>
<a name="l00010"></a>00010 <span class="preprocessor">#include &quot;../../fileio/lz.h&quot;</span>
<a name="l00011"></a>00011 <span class="preprocessor">#include &quot;../../graphics/CGfxEngine.h&quot;</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include &quot;../../sdl/CVideoDriver.h&quot;</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include &quot;../../fileio/TypeDefinitions.h&quot;</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include &quot;../../common/CBehaviorEngine.h&quot;</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include &quot;../../CLogFile.h&quot;</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include &quot;../CPlanes.h&quot;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &quot;../../keen.h&quot;</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include &quot;../../FindFile.h&quot;</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include &lt;SDL.h&gt;</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 CEGALatch::CEGALatch( <span class="keywordtype">int</span> planesize,
<a name="l00024"></a>00024       <span class="keywordtype">long</span> bitmaptablelocation,
<a name="l00025"></a>00025       <span class="keywordtype">short</span> fonttiles,
<a name="l00026"></a>00026       <span class="keywordtype">long</span> fontlocation,
<a name="l00027"></a>00027       <span class="keywordtype">long</span> screentiles,
<a name="l00028"></a>00028       <span class="keywordtype">long</span> screenlocation,
<a name="l00029"></a>00029       <span class="keywordtype">short</span> num16tiles,
<a name="l00030"></a>00030       <span class="keywordtype">long</span> tiles16location,
<a name="l00031"></a>00031       <span class="keywordtype">short</span> bitmaps,
<a name="l00032"></a>00032       <span class="keywordtype">long</span> bitmaplocation) :
<a name="l00033"></a>00033 RawData(NULL)
<a name="l00034"></a>00034 {
<a name="l00035"></a>00035  m_latchplanesize = planesize;
<a name="l00036"></a>00036  m_bitmaptablelocation = bitmaptablelocation;
<a name="l00037"></a>00037  m_fonttiles = fonttiles;
<a name="l00038"></a>00038  m_fontlocation = fontlocation;
<a name="l00039"></a>00039  m_screentiles = screentiles;
<a name="l00040"></a>00040  m_screenlocation = screenlocation;
<a name="l00041"></a>00041  m_num16tiles = num16tiles;
<a name="l00042"></a>00042  m_tiles16location = tiles16location;
<a name="l00043"></a>00043  m_bitmaps = bitmaps;
<a name="l00044"></a>00044  m_bitmaplocation = bitmaplocation;
<a name="l00045"></a>00045 }
<a name="l00046"></a>00046 
<a name="l00047"></a>00047 <span class="keywordtype">bool</span> CEGALatch::loadHead( <span class="keywordtype">char</span> *data, <span class="keywordtype">short</span> m_episode )
<a name="l00048"></a>00048 {
<a name="l00049"></a>00049  Uint16 height, width;
<a name="l00050"></a>00050 
<a name="l00051"></a>00051  data += m_bitmaptablelocation;
<a name="l00052"></a>00052 
<a name="l00053"></a>00053  g_pGfxEngine-&gt;createEmptyBitmaps(m_bitmaps);
<a name="l00054"></a>00054  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0 ; i&lt;m_bitmaps ; i++)
<a name="l00055"></a>00055  {
<a name="l00056"></a>00056   std::string name;
<a name="l00057"></a>00057   <span class="comment">//char name[9];</span>
<a name="l00058"></a>00058   <a class="code" href="class_c_bitmap.html">CBitmap</a> &amp;Bitmap = g_pGfxEngine-&gt;getBitmap(i);
<a name="l00059"></a>00059   memcpy(&amp;width,data+16*i,2);
<a name="l00060"></a>00060   memcpy(&amp;height,data+16*i+2,2);
<a name="l00061"></a>00061   name = <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(data+16*i+8);
<a name="l00062"></a>00062   width *= 8; <span class="comment">// The width is always divided by eight when read</span>
<a name="l00063"></a>00063 
<a name="l00064"></a>00064   name = name.substr(0,8); <span class="comment">// Cut the rest of data down, if junk detected in the exe file</span>
<a name="l00065"></a>00065   TrimSpaces(name);
<a name="l00066"></a>00066   <span class="keywordflow">if</span>( name != <span class="stringliteral">&quot;&quot;</span> ) Bitmap.setName( name );
<a name="l00067"></a>00067   <span class="keywordflow">else</span>
<a name="l00068"></a>00068   {
<a name="l00069"></a>00069    <span class="keywordflow">if</span> (m_episode == 1)
<a name="l00070"></a>00070    {
<a name="l00071"></a>00071     <span class="keyword">const</span> std::string default_names[] = { <span class="stringliteral">&quot;TITLE&quot;</span>, <span class="stringliteral">&quot;IDLOGO&quot;</span>, <span class="stringliteral">&quot;F1HELP&quot;</span>, <span class="stringliteral">&quot;HIGHSCOR&quot;</span>,
<a name="l00072"></a>00072      <span class="stringliteral">&quot;NAME&quot;</span>, <span class="stringliteral">&quot;SCORE&quot;</span>, <span class="stringliteral">&quot;PARTS&quot;</span>, <span class="stringliteral">&quot;GAMEOVER&quot;</span>, <span class="stringliteral">&quot;AN&quot;</span>, <span class="stringliteral">&quot;PRESENT&quot;</span>, <span class="stringliteral">&quot;APOGEE&quot;</span>, <span class="stringliteral">&quot;KEENSHIP&quot;</span>, <span class="stringliteral">&quot;WINDON&quot;</span>,
<a name="l00073"></a>00073      <span class="stringliteral">&quot;WINDOFF&quot;</span>, <span class="stringliteral">&quot;ONEMOMEN&quot;</span>, <span class="stringliteral">&quot;OFAN&quot;</span>, <span class="stringliteral">&quot;PRODUCT&quot;</span>, <span class="stringliteral">&quot;IDSOFT&quot;</span> }; <span class="comment">// in case the names are empty</span>
<a name="l00074"></a>00074     Bitmap.setName( default_names[i] );
<a name="l00075"></a>00075    }
<a name="l00076"></a>00076    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m_episode == 2)
<a name="l00077"></a>00077    {
<a name="l00078"></a>00078     <span class="keyword">const</span> std::string default_names[] = { <span class="stringliteral">&quot;TITLE&quot;</span>, <span class="stringliteral">&quot;IDLOGO&quot;</span>, <span class="stringliteral">&quot;F1HELP&quot;</span>, <span class="stringliteral">&quot;HIGHSCOR&quot;</span>,
<a name="l00079"></a>00079      <span class="stringliteral">&quot;NAME&quot;</span>, <span class="stringliteral">&quot;SCORE&quot;</span>, <span class="stringliteral">&quot;SAVED&quot;</span>, <span class="stringliteral">&quot;GAMEOVER&quot;</span>, <span class="stringliteral">&quot;AN&quot;</span>, <span class="stringliteral">&quot;PRESENT&quot;</span>, <span class="stringliteral">&quot;APOGEE&quot;</span>, <span class="stringliteral">&quot;KEENSHIP&quot;</span>, <span class="stringliteral">&quot;WINDON&quot;</span>,
<a name="l00080"></a>00080      <span class="stringliteral">&quot;WINDOFF&quot;</span>, <span class="stringliteral">&quot;ONEMOMEN&quot;</span>, <span class="stringliteral">&quot;OFAN&quot;</span>, <span class="stringliteral">&quot;PRODUCT&quot;</span>, <span class="stringliteral">&quot;IDSOFT&quot;</span> }; <span class="comment">// in case the names are empty</span>
<a name="l00081"></a>00081     Bitmap.setName( default_names[i] );
<a name="l00082"></a>00082    }
<a name="l00083"></a>00083    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m_episode == 3)
<a name="l00084"></a>00084    {
<a name="l00085"></a>00085     <span class="keyword">const</span> std::string default_names[] = { <span class="stringliteral">&quot;TITLE&quot;</span>, <span class="stringliteral">&quot;IDLOGO&quot;</span>, <span class="stringliteral">&quot;F1HELP&quot;</span>, <span class="stringliteral">&quot;HIGHSCOR&quot;</span>,
<a name="l00086"></a>00086      <span class="stringliteral">&quot;NAME&quot;</span>, <span class="stringliteral">&quot;SCORE&quot;</span>, <span class="stringliteral">&quot;GAMEOVER&quot;</span>, <span class="stringliteral">&quot;AN&quot;</span>, <span class="stringliteral">&quot;PRESENT&quot;</span>, <span class="stringliteral">&quot;APOGEE&quot;</span>, <span class="stringliteral">&quot;ONEMOMEN&quot;</span>, <span class="stringliteral">&quot;OFAN&quot;</span>, <span class="stringliteral">&quot;PRODUCT&quot;</span>, <span class="stringliteral">&quot;IDSOFT&quot;</span> }; <span class="comment">// in case the names are empty</span>
<a name="l00087"></a>00087     Bitmap.setName( default_names[i] );
<a name="l00088"></a>00088    }
<a name="l00089"></a>00089   }
<a name="l00090"></a>00090   Bitmap.setDimensions(width,height);
<a name="l00091"></a>00091  }
<a name="l00092"></a>00092  <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00093"></a>00093 }
<a name="l00094"></a>00094 
<a name="l00095"></a><a class="code" href="class_c_e_g_a_latch.html#a1a7d1da130603628a08f17c94c4b2664">00095</a> <span class="keywordtype">bool</span> <a class="code" href="class_c_e_g_a_latch.html#a1a7d1da130603628a08f17c94c4b2664">CEGALatch::loadData</a>( std::string &amp;path, <span class="keywordtype">short</span> episode, <span class="keywordtype">int</span> version, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *data, <span class="keywordtype">bool</span> compresseddata )
<a name="l00096"></a>00096 {
<a name="l00097"></a>00097  std::string filename;
<a name="l00098"></a>00098  byte *RawData;
<a name="l00099"></a>00099     Uint16 width, height;
<a name="l00100"></a>00100     SDL_Surface *sfc;
<a name="l00101"></a>00101 
<a name="l00102"></a>00102  filename = getResourceFilename(<span class="stringliteral">&quot;egalatch.ck&quot;</span> + itoa(episode), path);
<a name="l00103"></a>00103 
<a name="l00104"></a>00104  FILE* latchfile = OpenGameFile(filename,<span class="stringliteral">&quot;rb&quot;</span>);
<a name="l00105"></a>00105 
<a name="l00106"></a>00106  <span class="keywordflow">if</span>(!latchfile)
<a name="l00107"></a>00107   <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00108"></a>00108 
<a name="l00109"></a>00109  RawData = <span class="keyword">new</span> byte[m_latchplanesize * 4];
<a name="l00110"></a>00110     <span class="comment">// get the data out of the file into the memory, decompressing it if necessary.</span>
<a name="l00111"></a>00111     <span class="keywordflow">if</span> (compresseddata)
<a name="l00112"></a>00112     {
<a name="l00113"></a>00113   <span class="keywordflow">if</span> (lz_decompress(latchfile, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) RawData))
<a name="l00114"></a>00114    <span class="keywordflow">return</span> 1;
<a name="l00115"></a>00115     }
<a name="l00116"></a>00116     <span class="keywordflow">else</span>
<a name="l00117"></a>00117     {
<a name="l00118"></a>00118      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0 ; i&lt;(m_latchplanesize*4) ; i++)
<a name="l00119"></a>00119       RawData[i] = fgetc(latchfile);
<a name="l00120"></a>00120     }
<a name="l00121"></a>00121 
<a name="l00122"></a>00122     fclose(latchfile);
<a name="l00123"></a>00123 
<a name="l00124"></a>00124  <span class="comment">// these are the offsets of the different video planes as</span>
<a name="l00125"></a>00125  <span class="comment">// relative to each other--that is if a pixel in plane1</span>
<a name="l00126"></a>00126  <span class="comment">// is at N, the byte for that same pixel in plane3 will be</span>
<a name="l00127"></a>00127  <span class="comment">// at (N + plane3).</span>
<a name="l00128"></a>00128  <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> plane1, plane2, plane3, plane4;
<a name="l00129"></a>00129 
<a name="l00130"></a>00130  plane1 = 0;
<a name="l00131"></a>00131  plane2 = (m_latchplanesize * 1);
<a name="l00132"></a>00132  plane3 = (m_latchplanesize * 2);
<a name="l00133"></a>00133  plane4 = (m_latchplanesize * 3);
<a name="l00134"></a>00134 
<a name="l00135"></a>00135  <span class="comment">// ** read the 8x8 tiles **</span>
<a name="l00136"></a>00136  <span class="comment">// set up the getbit() function of CPlanes class</span>
<a name="l00137"></a>00137  <a class="code" href="class_c_planes.html">CPlanes</a> Planes(RawData);
<a name="l00138"></a>00138  Planes.<a class="code" href="class_c_planes.html#aa1713e4cec9409fc7aa5363d798da3d3" title="THis function is used for setting the offsets, so the bits can be read.">setOffsets</a>(plane1 + m_fontlocation, plane2 + m_fontlocation,
<a name="l00139"></a>00139        plane3 + m_fontlocation, plane4 + m_fontlocation, 0);
<a name="l00140"></a>00140  <span class="comment">// Load these graphics into the CFont Class of CGfxEngine</span>
<a name="l00141"></a>00141  <span class="comment">// The original vorticon engine only uses one fontmap, but we use another for</span>
<a name="l00142"></a>00142  <span class="comment">// extra icons. For example sliders are in that map</span>
<a name="l00143"></a>00143  g_pGfxEngine-&gt;createEmptyFontmaps(2);
<a name="l00144"></a>00144  <a class="code" href="class_c_font.html">CFont</a> &amp;Font = g_pGfxEngine-&gt;getFont(0);
<a name="l00145"></a>00145  Font.destroySurface();
<a name="l00146"></a>00146  Font.CreateSurface( g_pGfxEngine-&gt;Palette.m_Palette, SDL_SWSURFACE );
<a name="l00147"></a>00147  sfc = Font.getSDLSurface();
<a name="l00148"></a>00148 
<a name="l00149"></a>00149  <span class="keywordflow">if</span>(SDL_MUSTLOCK(sfc)) SDL_LockSurface(sfc);
<a name="l00150"></a>00150 
<a name="l00151"></a>00151  Uint8 *pixel = (Uint8*) sfc-&gt;pixels;
<a name="l00152"></a>00152  SDL_FillRect(sfc, NULL, 0);
<a name="l00153"></a>00153 
<a name="l00154"></a>00154  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> p=0;p&lt;4;p++)
<a name="l00155"></a>00155   Planes.<a class="code" href="class_c_planes.html#ab3470959e52a76f407078df080aa5838">readPlaneofTiles</a>(p, pixel, 16, 8, m_fonttiles);
<a name="l00156"></a>00156 
<a name="l00157"></a>00157  <span class="keywordflow">if</span>(SDL_MUSTLOCK(sfc)) SDL_UnlockSurface(sfc);
<a name="l00158"></a>00158 
<a name="l00159"></a>00159  <span class="comment">// Load Hi-Colour VGA, SVGA 8x8 Tiles into the fontmap</span>
<a name="l00160"></a>00160  filename = getResourceFilename(<span class="stringliteral">&quot;gfx/fonts.bmp&quot;</span>, path, <span class="keyword">false</span>);
<a name="l00161"></a>00161 
<a name="l00162"></a>00162  Font.optimizeSurface();
<a name="l00163"></a>00163  <span class="keywordflow">if</span>(Font.loadHiColourFont(filename)) <span class="comment">// This is loaded again in order to get hi-colour fonts</span>
<a name="l00164"></a>00164   g_pLogFile-&gt;textOut(GREEN, <span class="stringliteral">&quot;VGA Fontmap for the game has been loaded successfully!&quot;</span>);
<a name="l00165"></a>00165 
<a name="l00166"></a>00166  Font.setFGColour(Font.getSDLSurface()-&gt;format, 0x0, <span class="keyword">true</span>);
<a name="l00167"></a>00167 
<a name="l00168"></a>00168  <span class="comment">// Setup the twirl</span>
<a name="l00169"></a>00169  g_pGfxEngine-&gt;createEmptyCursorMap(Font.getSDLColouredSurface());
<a name="l00170"></a>00170  <a class="code" href="class_c_cursor.html">CCursor</a> *pCursor = g_pGfxEngine-&gt;getCursor();
<a name="l00171"></a>00171  pCursor-&gt;generateTwirls(Font);
<a name="l00172"></a>00172 
<a name="l00173"></a>00173  <span class="comment">// The second fontmap of the extra tilemap code goes here! (for example Sliders)</span>
<a name="l00174"></a>00174  <a class="code" href="class_c_font.html">CFont</a> &amp;Font2 = g_pGfxEngine-&gt;getFont(1);
<a name="l00175"></a>00175  Font2.destroySurface();
<a name="l00176"></a>00176  Font2.CreateSurface( g_pGfxEngine-&gt;Palette.m_Palette, SDL_SWSURFACE );
<a name="l00177"></a>00177  Font2.optimizeSurface();
<a name="l00178"></a>00178 
<a name="l00179"></a>00179  filename = getResourceFilename(<span class="stringliteral">&quot;gfx/extratiles.bmp&quot;</span>, path, <span class="keyword">true</span>, <span class="keyword">true</span>);
<a name="l00180"></a>00180 
<a name="l00181"></a>00181  <span class="keywordflow">if</span>(filename == <span class="stringliteral">&quot;&quot;</span>) <span class="comment">// That essential file was not found! Try to exit</span>
<a name="l00182"></a>00182   <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00183"></a>00183 
<a name="l00184"></a>00184  Font2.loadHiColourFont(filename);
<a name="l00185"></a>00185 
<a name="l00186"></a>00186  Font2.setFGColour(Font2.getSDLSurface()-&gt;format, 0x0, <span class="keyword">true</span>);
<a name="l00187"></a>00187 
<a name="l00188"></a>00188  <span class="comment">// Load 32x32 Tiles</span>
<a name="l00189"></a>00189  <span class="comment">// TODO: Add a read method for 32x32 Tiles</span>
<a name="l00190"></a>00190 
<a name="l00191"></a>00191  <span class="comment">// ** read the 16x16 tiles **</span>
<a name="l00192"></a>00192  Planes.<a class="code" href="class_c_planes.html#aa1713e4cec9409fc7aa5363d798da3d3" title="THis function is used for setting the offsets, so the bits can be read.">setOffsets</a>(plane1 + m_tiles16location,
<a name="l00193"></a>00193       plane2 + m_tiles16location,
<a name="l00194"></a>00194       plane3 + m_tiles16location,
<a name="l00195"></a>00195       plane4 + m_tiles16location,
<a name="l00196"></a>00196       0);
<a name="l00197"></a>00197 
<a name="l00198"></a>00198  g_pGfxEngine-&gt;createEmptyTilemap(2);
<a name="l00199"></a>00199  <a class="code" href="class_c_tilemap.html">CTilemap</a> &amp;Tilemap = g_pGfxEngine-&gt;getTileMap(1);
<a name="l00200"></a>00200  Tilemap.CreateSurface( g_pGfxEngine-&gt;Palette.m_Palette, SDL_SWSURFACE, m_num16tiles, 4, 13 );
<a name="l00201"></a>00201  sfc = Tilemap.getSDLSurface();
<a name="l00202"></a>00202  SDL_FillRect(sfc,NULL, 0);
<a name="l00203"></a>00203  <span class="keywordflow">if</span>(SDL_MUSTLOCK(sfc)) SDL_LockSurface(sfc);
<a name="l00204"></a>00204  Uint8 *u_pixel = (Uint8*) sfc-&gt;pixels;
<a name="l00205"></a>00205 
<a name="l00206"></a>00206  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> p=0;p&lt;4;p++)
<a name="l00207"></a>00207   Planes.<a class="code" href="class_c_planes.html#ab3470959e52a76f407078df080aa5838">readPlaneofTiles</a>(p, u_pixel, 13, 16, m_num16tiles);
<a name="l00208"></a>00208 
<a name="l00209"></a>00209  <span class="keywordflow">if</span>(SDL_MUSTLOCK(sfc)) SDL_UnlockSurface(sfc);
<a name="l00210"></a>00210 
<a name="l00211"></a>00211  <span class="comment">// Load Hi-Colour, VGA, SVGA Tiles into the tilemap</span>
<a name="l00212"></a>00212  filename = getResourceFilename(<span class="stringliteral">&quot;gfx/ck&quot;</span> + itoa(episode) + <span class="stringliteral">&quot;tiles.bmp&quot;</span>, path, <span class="keyword">false</span>);
<a name="l00213"></a>00213  <span class="keywordflow">if</span>(Tilemap.loadHiresTile(filename))
<a name="l00214"></a>00214   g_pLogFile-&gt;textOut(GREEN, <span class="stringliteral">&quot;VGA Bitmap for Tileset has been loaded successfully!&quot;</span>);
<a name="l00215"></a>00215 
<a name="l00216"></a>00216  <span class="comment">// Adapt the tilemap to the display, so they are faster blit</span>
<a name="l00217"></a>00217  Tilemap.optimizeSurface();
<a name="l00218"></a>00218 
<a name="l00219"></a>00219  <span class="comment">// make masked tiles according to it&#39;s surfaces</span>
<a name="l00220"></a>00220  applyMasks();
<a name="l00221"></a>00221 <span class="comment"></span>
<a name="l00222"></a>00222 <span class="comment"> ////////////////////</span>
<a name="l00223"></a>00223 <span class="comment"> /// Load Bitmaps ///</span>
<a name="l00224"></a>00224 <span class="comment"> ////////////////////</span>
<a name="l00225"></a>00225 <span class="comment"></span>
<a name="l00226"></a>00226  Planes.<a class="code" href="class_c_planes.html#aa1713e4cec9409fc7aa5363d798da3d3" title="THis function is used for setting the offsets, so the bits can be read.">setOffsets</a>(plane1 + m_bitmaplocation,
<a name="l00227"></a>00227      plane2 + m_bitmaplocation,
<a name="l00228"></a>00228      plane3 + m_bitmaplocation,
<a name="l00229"></a>00229      plane4 + m_bitmaplocation,
<a name="l00230"></a>00230      0);
<a name="l00231"></a>00231 
<a name="l00232"></a>00232  <span class="comment">// decode bitmaps into the BitmapData structure. The bitmaps are</span>
<a name="l00233"></a>00233  <span class="comment">// loaded into one continuous stream of image data, with the bitmaps[]</span>
<a name="l00234"></a>00234  <span class="comment">// array giving pointers to where each bitmap starts within the stream.</span>
<a name="l00235"></a>00235 
<a name="l00236"></a>00236  <span class="comment">// In case there is a strange mod or defect episode, put some names to them!</span>
<a name="l00237"></a>00237  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> b=0 ; b&lt;m_bitmaps ; b++)
<a name="l00238"></a>00238  {
<a name="l00239"></a>00239      <a class="code" href="class_c_bitmap.html">CBitmap</a> &amp;bitmap = g_pGfxEngine-&gt;getBitmap(b);
<a name="l00240"></a>00240   bitmap.createSurface(g_pVideoDriver-&gt;getScrollSurface()-&gt;flags, g_pGfxEngine-&gt;Palette.m_Palette);
<a name="l00241"></a>00241  }
<a name="l00242"></a>00242 
<a name="l00243"></a>00243  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> p=0 ; p&lt;4 ; p++)
<a name="l00244"></a>00244  {
<a name="l00245"></a>00245   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> b=0 ; b&lt;m_bitmaps ; b++)
<a name="l00246"></a>00246   {
<a name="l00247"></a>00247       <a class="code" href="class_c_bitmap.html">CBitmap</a> &amp;bitmap = g_pGfxEngine-&gt;getBitmap(b);
<a name="l00248"></a>00248    <span class="comment">// this points to the location that we&#39;re currently</span>
<a name="l00249"></a>00249    <span class="comment">// decoding bitmap data to</span>
<a name="l00250"></a>00250 
<a name="l00251"></a>00251    sfc= bitmap.getSDLSurface();
<a name="l00252"></a>00252    <span class="keywordflow">if</span>(SDL_MUSTLOCK(sfc)) SDL_LockSurface(sfc);
<a name="l00253"></a>00253    Uint8* pixel = (Uint8*) sfc-&gt;pixels;
<a name="l00254"></a>00254    <span class="keywordflow">if</span>(p==0)
<a name="l00255"></a>00255     SDL_FillRect(sfc, NULL, 0);
<a name="l00256"></a>00256    width = bitmap.getWidth(); height = bitmap.getHeight();
<a name="l00257"></a>00257    <span class="comment">// Now read the raw data</span>
<a name="l00258"></a>00258 
<a name="l00259"></a>00259    Planes.<a class="code" href="class_c_planes.html#a87f413375d2b1197590983a7f48c7e97">readPlane</a>(p, pixel, width, height);
<a name="l00260"></a>00260 
<a name="l00261"></a>00261    <span class="keywordflow">if</span>(SDL_MUSTLOCK(sfc)) SDL_UnlockSurface(sfc);
<a name="l00262"></a>00262   }
<a name="l00263"></a>00263  }
<a name="l00264"></a>00264 
<a name="l00265"></a>00265  <span class="comment">// optimize the bitmaps and load hq bitmaps if there are some.</span>
<a name="l00266"></a>00266  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> b=0 ; b&lt;m_bitmaps ; b++)
<a name="l00267"></a>00267  {
<a name="l00268"></a>00268   <a class="code" href="class_c_bitmap.html">CBitmap</a> &amp;bitmap = g_pGfxEngine-&gt;getBitmap(b);
<a name="l00269"></a>00269   bitmap.optimizeSurface();
<a name="l00270"></a>00270   filename = getResourceFilename(<span class="stringliteral">&quot;gfx/bitmap&quot;</span> + itoa(b) + <span class="stringliteral">&quot;.bmp&quot;</span>, path, <span class="keyword">false</span>);
<a name="l00271"></a>00271   bitmap.loadHQBitmap(filename);
<a name="l00272"></a>00272  }
<a name="l00273"></a>00273 
<a name="l00274"></a>00274  <span class="keywordflow">if</span>(RawData){ <span class="keyword">delete</span>[] RawData; RawData = NULL;}
<a name="l00275"></a>00275 
<a name="l00276"></a>00276  <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00277"></a>00277 }
<a name="l00278"></a>00278 
<a name="l00279"></a>00279 <span class="comment">// Convert the normal tiles to masked tiles</span>
<a name="l00280"></a>00280 <span class="keywordtype">void</span> CEGALatch::applyMasks()
<a name="l00281"></a>00281 {
<a name="l00282"></a>00282  SDL_Surface *sfc;
<a name="l00283"></a>00283  Uint32 u_colour = 0;
<a name="l00284"></a>00284  SDL_Rect rect;
<a name="l00285"></a>00285  Uint8 bpp;
<a name="l00286"></a>00286  Uint8 r,g,b,alpha;
<a name="l00287"></a>00287  Uint8 *u_offset;
<a name="l00288"></a>00288 
<a name="l00289"></a>00289  sfc = g_pGfxEngine-&gt;getTileMap(1).getSDLSurface();
<a name="l00290"></a>00290 
<a name="l00291"></a>00291  <span class="keywordflow">if</span>(SDL_MUSTLOCK(sfc)) SDL_LockSurface(sfc);
<a name="l00292"></a>00292 
<a name="l00293"></a>00293  bpp = sfc-&gt;format-&gt;BytesPerPixel;
<a name="l00294"></a>00294  rect.w = rect.h = 1;
<a name="l00295"></a>00295 
<a name="l00296"></a>00296  <span class="keywordflow">for</span>( Uint16 t=0 ; t&lt;m_num16tiles ; t++ )
<a name="l00297"></a>00297  {
<a name="l00298"></a>00298   <span class="keywordflow">if</span>( g_pBehaviorEngine-&gt;getTileProperties().at(t).behaviour == -2 )  <span class="comment">// This is for masked tiles.</span>
<a name="l00299"></a>00299   {
<a name="l00300"></a>00300    <span class="keywordflow">for</span>( Uint16 x=0 ; x&lt;16 ; x++ )
<a name="l00301"></a>00301    {
<a name="l00302"></a>00302     <span class="keywordflow">for</span>( Uint16 y=0 ; y&lt;16 ; y++ )
<a name="l00303"></a>00303     {
<a name="l00304"></a>00304      u_offset = (Uint8*)sfc-&gt;pixels + bpp*((y+16*((t+1)/13))*13*16 + 16*((t+1)%13) + x);
<a name="l00305"></a>00305      memcpy( &amp;u_colour, u_offset, bpp);
<a name="l00306"></a>00306      SDL_GetRGB( u_colour, sfc-&gt;format, &amp;r, &amp;g, &amp;b);
<a name="l00307"></a>00307 
<a name="l00308"></a>00308      rect.x = 16*((t+1)%13) + x;
<a name="l00309"></a>00309      rect.y = y+16*((t+1)/13);
<a name="l00310"></a>00310 
<a name="l00311"></a>00311      <span class="keywordflow">if</span>( r&gt;=250 &amp;&amp; g&gt;=250 &amp;&amp; b&gt;=250 ) <span class="comment">// In this case set it to zero</span>
<a name="l00312"></a>00312      {
<a name="l00313"></a>00313       SDL_FillRect(sfc, &amp;rect, SDL_MapRGBA(sfc-&gt;format, 0, 0, 0, 0));
<a name="l00314"></a>00314      }
<a name="l00315"></a>00315      <span class="keywordflow">else</span> <span class="comment">// Get the pixel of the previous tile. If the mask has colour, use alpha channel, black is opaque</span>
<a name="l00316"></a>00316      {
<a name="l00317"></a>00317       alpha = 255 - (r+g+b)/3;
<a name="l00318"></a>00318       u_offset = (Uint8*)sfc-&gt;pixels + bpp*((y+16*(t/13))*13*16 + 16*(t%13) + x);
<a name="l00319"></a>00319       memcpy( &amp;u_colour, u_offset, bpp);
<a name="l00320"></a>00320       SDL_GetRGB( u_colour, sfc-&gt;format, &amp;r, &amp;g, &amp;b);
<a name="l00321"></a>00321       SDL_FillRect(sfc, &amp;rect, SDL_MapRGBA(sfc-&gt;format,r,g,b,alpha));
<a name="l00322"></a>00322      }
<a name="l00323"></a>00323     }
<a name="l00324"></a>00324    }
<a name="l00325"></a>00325   }
<a name="l00326"></a>00326  }
<a name="l00327"></a>00327 
<a name="l00328"></a>00328  <span class="keywordflow">if</span>(SDL_MUSTLOCK(sfc)) SDL_UnlockSurface(sfc);
<a name="l00329"></a>00329 }
<a name="l00330"></a>00330 
<a name="l00331"></a>00331 CEGALatch::~CEGALatch() {
<a name="l00332"></a>00332  <span class="keywordflow">if</span>(RawData) <span class="keyword">delete</span> [] RawData, RawData = NULL;
<a name="l00333"></a>00333 }
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
